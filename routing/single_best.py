'''
This module provides the functionality to find the single best route
defined by the maximum number of deliveries performed over a "reasonable short route".

Additionally, a single pickup location needs to be approached.
'''

import numpy as np
from .weighted_route_builder import build_route, rebuild_route
from .utils import get_capacity
from .route_validator import validate_length_one_pickup


def single_best(
        van_capacity, deliveries, pickups,
        generations, spawn_rate=5, survival_rate=5, seed=None):
    '''
    This function tries to find the single best route a given delivery van can service.

    The route starts at the depot at (0, 0). Each following destination is picked by random draw
    where the events are weighted by their distance to the current position (farther events have
    lower probabilities to be drawn). Events are drawn until the capacity of the van is exhausted
    and it has to return back to the depot. 
    On the route, the van has to stop at exactly one pickup location.

    After the first route is build, from this "parent-route", `spawn_rate` "child-routes" are
    generated by randomly picking an event along the route and dropping all events after it.
    From there, the route is rebuild by randomly redrawing new events.
    Afterwards, all child-routes are sorted by their length (shorter routes to the front) and their
    number of stops (the maximum number to the front, everything else to the back) and the best
    `survival_rate` routes are kept and used as parents in the next generation.
    This evolution runs `generations` times until the very "best" route is returned.
    '''

    np.random.seed(seed)
    route, evt_types = build_route(deliveries, pickups, van_capacity)

    route_length, valid = validate_length_one_pickup(
        route, evt_types, deliveries, pickups)
    routes = [(route, evt_types, route_length)]

    max_stops = len(route)

    while generations > 0:
        generations -= 1

        # make a shallow copy of the route list so not to loop over the same list that gets modified
        loop_routes = routes.copy()

        for r, e, c in loop_routes:
            for _ in range(spawn_rate):

                new_route, new_evt_types = rebuild_route(
                    deliveries, pickups, van_capacity, r, e)

                route_length, valid = validate_length_one_pickup(
                    new_route, new_evt_types, deliveries, pickups)

                max_stops = max(max_stops, len(new_route))

                if valid:
                    routes += [(new_route, new_evt_types, route_length)]

        # remove possible duplicates
        unique_routes = []
        for r in routes:
            if r not in unique_routes:
                unique_routes.append(r)
        routes = unique_routes

        # only let the best `survival_rate` routes survive to the next generation
        if len(routes) > survival_rate:
            routes.sort(key=lambda r: (len(r[0]) == max_stops) / r[2], reverse=True)
            routes = routes[:survival_rate]

    # the way the capacity is calculated, especially concerning pickups, the route is essentially
    # "backwards", so reverse it here before returning
    route, evts, length = routes[0]
    route.reverse()
    evts.reverse()
    # also add depot events at the beginning and end of the route
    route = [-1] + route + [-1]
    evts = ['o'] + evts + ['o']
    return route, evts, length

